{"version":3,"sources":["skylark-graphics-image-all.js"],"names":["define","obj1","path","obj2","split","length","ns","i","name","_attach","skylark","attach","obj","imagex","urlAPI","URL","webkitURL","revokeHelper","img","options","_objectURL","noRevoke","revokeObjectURL","fetchBlob","url","callback","isInstanceOf","type","Object","prototype","toString","call","transform","file","data","onerror","event","onload","createObjectURL","readFile","method","FileReader","fileReader","meta","hasblobSlice","Blob","slice","webkitSlice","mozSlice","blobSlice","this","apply","arguments","metaDataParsers","jpeg","65505","65517","parseMetaData","that","maxMetaDataSize","noMetaData","DataView","size","e","target","error","console","log","markerBytes","markerLength","parsers","buffer","result","dataView","offset","maxOffset","byteLength","headLength","getUint16","disableImageHead","imageHead","Uint8Array","subarray","hasMetaOption","originalTransform","exif","ExifMap","map","Orientation","get","id","getExifThumbnail","loadImage","exifTagTypes","1","getValue","dataOffset","getUint8","2","String","fromCharCode","ascii","3","littleEndian","4","getUint32","5","9","getInt32","10","getExifValue","tiffOffset","tagSize","values","str","c","tagType","parseExifTag","tag","parseExifTags","dirOffset","tagsNumber","dirEndOffset","parseExifData","disableExif","thumbnailData","disableExifThumbnail","Thumbnail","disableExifSub","disableExifGps","push","renderImageToCanvas","canvas","sourceX","sourceY","sourceWidth","sourceHeight","destX","destY","destWidth","destHeight","getContext","drawImage","scale","maxWidth","maxHeight","minWidth","minHeight","pixelRatio","downsamplingRatio","tmp","document","createElement","useCanvas","crop","aspectRatio","hasCanvasOption","width","naturalWidth","height","naturalHeight","scaleUp","Math","max","scaleDown","min","newOptions","hasOwnProperty","getTransformedOptions","left","top","undefined","right","bottom","contain","cover","style","loadFile","blob","crossOrigin","src","main"],"mappings":"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","file":"../skylark-graphics-image-all.js","sourcesContent":["define('skylark-langx/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        return ns[name] = obj2;\r\n    }\r\n});\ndefine('skylark-langx/skylark',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var skylark = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(skylark,path,obj);\r\n    \t}\r\n    };\r\n    return skylark;\r\n});\r\n\ndefine('skylark-graphics-image/imagex',[\r\n\t\"skylark-langx/skylark\"\r\n],function(skylark){\r\n\r\n\tvar imagex = {};\r\n\r\n\t// The check for URL.revokeObjectURL fixes an issue with Opera 12,\r\n\t// which provides URL.createObjectURL but doesn't properly implement it:\r\n\tvar urlAPI = URL || webkitURL;\r\n\r\n\tfunction revokeHelper (img, options) {\r\n\t\tif (img._objectURL && !(options && options.noRevoke)) {\r\n\t\t  imagex.revokeObjectURL(img._objectURL)\r\n\t\t  delete img._objectURL\r\n\t\t}\r\n\t}\r\n\r\n\t// If the callback given to this function returns a blob, it is used as image\r\n\t// source instead of the original url and overrides the file argument used in\r\n\t// the onload and onerror event callbacks:\r\n\timagex.fetchBlob = function (url, callback, options) {\r\n\t\tcallback();\r\n\t}\r\n\r\n\timagex.isInstanceOf = function (type, obj) {\r\n\t\t// Cross-frame instanceof check\r\n\t\treturn Object.prototype.toString.call(obj) === '[object ' + type + ']'\r\n\t}\r\n\r\n\timagex.transform = function (img, options, callback, file, data) {\r\n\t\tcallback(img, data)\r\n\t}\r\n\r\n\timagex.onerror = function (img, event, file, callback, options) {\r\n\t\trevokeHelper(img, options)\r\n\t\tif (callback) {\r\n\t\t  callback.call(img, event)\r\n\t\t}\r\n\t}\r\n\r\n\timagex.onload = function (img, event, file, callback, options) {\r\n\t\trevokeHelper(img, options)\r\n\t\tif (callback) {\r\n\t\t  imagex.transform(img, options, callback, file, {})\r\n\t\t}\r\n\t}\r\n\r\n\timagex.createObjectURL = function (file) {\r\n\t\treturn urlAPI ? urlAPI.createObjectURL(file) : false\r\n\t}\r\n\r\n\timagex.revokeObjectURL = function (url) {\r\n\t\treturn urlAPI ? urlAPI.revokeObjectURL(url) : false\r\n\t}\r\n\r\n\t// Loads a given File object via FileReader interface,\r\n\t// invokes the callback with the event object (load or error).\r\n\t// The result can be read via event.target.result:\r\n\timagex.readFile = function (file, callback, method) {\r\n\t\tif (FileReader) {\r\n\t\t  var fileReader = new FileReader()\r\n\t\t  fileReader.onload = fileReader.onerror = callback\r\n\t\t  method = method || 'readAsDataURL'\r\n\t\t  if (fileReader[method]) {\r\n\t\t    fileReader[method](file)\r\n\t\t    return fileReader\r\n\t\t  }\r\n\t\t}\r\n\t\treturn false\r\n\t}\r\n\t\r\n\treturn skylark.imagex = imagex;\r\n});\ndefine('skylark-graphics-image/meta',[\r\n  \"./imagex\",\r\n], function(imagex) {\r\n  'use strict'\r\n\r\n  var meta = {};\r\n\r\n  var hasblobSlice =\r\n    typeof Blob !== 'undefined' &&\r\n    (Blob.prototype.slice ||\r\n      Blob.prototype.webkitSlice ||\r\n      Blob.prototype.mozSlice)\r\n\r\n  imagex.blobSlice =\r\n    hasblobSlice &&\r\n    function () {\r\n      var slice = this.slice || this.webkitSlice || this.mozSlice\r\n      return slice.apply(this, arguments)\r\n    }\r\n\r\n  meta.metaDataParsers = {\r\n    jpeg: {\r\n      0xffe1: [], // APP1 marker\r\n      0xffed: [] // APP13 marker\r\n    }\r\n  }\r\n\r\n  // Parses image meta data and calls the callback with an object argument\r\n  // with the following properties:\r\n  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\r\n  // The options argument accepts an object and supports the following\r\n  // properties:\r\n  // * maxMetaDataSize: Defines the maximum number of bytes to parse.\r\n  // * disableImageHead: Disables creating the imageHead property.\r\n  meta.parseMetaData = function (file, callback, options, data) {\r\n    options = options || {}\r\n    data = data || {}\r\n    var that = this\r\n    // 256 KiB should contain all EXIF/ICC/IPTC segments:\r\n    var maxMetaDataSize = options.maxMetaDataSize || 262144\r\n    var noMetaData = !(\r\n      typeof DataView !== 'undefined' &&\r\n      file &&\r\n      file.size >= 12 &&\r\n      file.type === 'image/jpeg' &&\r\n      imagex.blobSlice\r\n    )\r\n    if (\r\n      noMetaData ||\r\n      !imagex.readFile(\r\n        imagex.blobSlice.call(file, 0, maxMetaDataSize),\r\n        function (e) {\r\n          if (e.target.error) {\r\n            // FileReader error\r\n            console.log(e.target.error)\r\n            callback(data)\r\n            return\r\n          }\r\n          // Note on endianness:\r\n          // Since the marker and length bytes in JPEG files are always\r\n          // stored in big endian order, we can leave the endian parameter\r\n          // of the DataView methods undefined, defaulting to big endian.\r\n          var buffer = e.target.result\r\n          var dataView = new DataView(buffer)\r\n          var offset = 2\r\n          var maxOffset = dataView.byteLength - 4\r\n          var headLength = offset\r\n          var markerBytes\r\n          var markerLength\r\n          var parsers\r\n          var i\r\n          // Check for the JPEG marker (0xffd8):\r\n          if (dataView.getUint16(0) === 0xffd8) {\r\n            while (offset < maxOffset) {\r\n              markerBytes = dataView.getUint16(offset)\r\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\r\n              // which contain application-specific meta-data like\r\n              // Exif, ICC and IPTC data and text comments:\r\n              if (\r\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\r\n                markerBytes === 0xfffe\r\n              ) {\r\n                // The marker bytes (2) are always followed by\r\n                // the length bytes (2), indicating the length of the\r\n                // marker segment, which includes the length bytes,\r\n                // but not the marker bytes, so we add 2:\r\n                markerLength = dataView.getUint16(offset + 2) + 2\r\n                if (offset + markerLength > dataView.byteLength) {\r\n                  console.log('Invalid meta data: Invalid segment size.')\r\n                  break\r\n                }\r\n                parsers = meta.metaDataParsers.jpeg[markerBytes]\r\n                if (parsers) {\r\n                  for (i = 0; i < parsers.length; i += 1) {\r\n                    parsers[i].call(\r\n                      that,\r\n                      dataView,\r\n                      offset,\r\n                      markerLength,\r\n                      data,\r\n                      options\r\n                    )\r\n                  }\r\n                }\r\n                offset += markerLength\r\n                headLength = offset\r\n              } else {\r\n                // Not an APPn or COM marker, probably safe to\r\n                // assume that this is the end of the meta data\r\n                break\r\n              }\r\n            }\r\n            // Meta length must be longer than JPEG marker (2)\r\n            // plus APPn marker (2), followed by length bytes (2):\r\n            if (!options.disableImageHead && headLength > 6) {\r\n              if (buffer.slice) {\r\n                data.imageHead = buffer.slice(0, headLength)\r\n              } else {\r\n                // Workaround for IE10, which does not yet\r\n                // support ArrayBuffer.slice:\r\n                data.imageHead = new Uint8Array(buffer).subarray(0, headLength)\r\n              }\r\n            }\r\n          } else {\r\n            console.log('Invalid JPEG file: Missing JPEG marker.')\r\n          }\r\n          callback(data)\r\n        },\r\n        'readAsArrayBuffer'\r\n      )\r\n    ) {\r\n      callback(data)\r\n    }\r\n  }\r\n\r\n  // Determines if meta data should be loaded automatically:\r\n  meta.hasMetaOption = function (options) {\r\n    return options && options.meta\r\n  }\r\n\r\n  var originalTransform = imagex.transform\r\n  imagex.transform = function (img, options, callback, file, data) {\r\n    if (meta.hasMetaOption(options)) {\r\n      meta.parseMetaData(\r\n        file,\r\n        function (data) {\r\n          originalTransform.call(imagex, img, options, callback, file, data)\r\n        },\r\n        options,\r\n        data\r\n      )\r\n    } else {\r\n      originalTransform.apply(imagex, arguments)\r\n    }\r\n  }\r\n\r\n  return imagex.meta = meta;\r\n});\ndefine('skylark-graphics-image/exif',[\r\n  \"./imagex\",\r\n  \"./meta\"\r\n], function(imagex,meta) {\r\n   //The module code is based from blueimp/JavaScript-Load-Image\r\n   // original : https://github.com/blueimp/JavaScript-Load-Image/blob/master/js/load-image-scale.js\r\n   // license  : MIT\r\n\r\n 'use strict'\r\n  var exif = function() {\r\n\r\n  };\r\n\r\n\r\n  exif.ExifMap = function () {\r\n    return this\r\n  }\r\n\r\n  exif.ExifMap.prototype.map = {\r\n    Orientation: 0x0112\r\n  }\r\n\r\n  exif.ExifMap.prototype.get = function (id) {\r\n    return this[id] || this[this.map[id]]\r\n  }\r\n\r\n  exif.getExifThumbnail = function (dataView, offset, length) {\r\n    if (!length || offset + length > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid thumbnail data.')\r\n      return\r\n    }\r\n    return loadImage.createObjectURL(\r\n      new Blob([dataView.buffer.slice(offset, offset + length)])\r\n    )\r\n  }\r\n\r\n  exif.exifTagTypes = {\r\n    // byte, 8-bit unsigned int:\r\n    1: {\r\n      getValue: function (dataView, dataOffset) {\r\n        return dataView.getUint8(dataOffset)\r\n      },\r\n      size: 1\r\n    },\r\n    // ascii, 8-bit byte:\r\n    2: {\r\n      getValue: function (dataView, dataOffset) {\r\n        return String.fromCharCode(dataView.getUint8(dataOffset))\r\n      },\r\n      size: 1,\r\n      ascii: true\r\n    },\r\n    // short, 16 bit int:\r\n    3: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return dataView.getUint16(dataOffset, littleEndian)\r\n      },\r\n      size: 2\r\n    },\r\n    // long, 32 bit int:\r\n    4: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return dataView.getUint32(dataOffset, littleEndian)\r\n      },\r\n      size: 4\r\n    },\r\n    // rational = two long values, first is numerator, second is denominator:\r\n    5: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return (\r\n          dataView.getUint32(dataOffset, littleEndian) /\r\n          dataView.getUint32(dataOffset + 4, littleEndian)\r\n        )\r\n      },\r\n      size: 8\r\n    },\r\n    // slong, 32 bit signed int:\r\n    9: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return dataView.getInt32(dataOffset, littleEndian)\r\n      },\r\n      size: 4\r\n    },\r\n    // srational, two slongs, first is numerator, second is denominator:\r\n    10: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return (\r\n          dataView.getInt32(dataOffset, littleEndian) /\r\n          dataView.getInt32(dataOffset + 4, littleEndian)\r\n        )\r\n      },\r\n      size: 8\r\n    }\r\n  }\r\n  // undefined, 8-bit byte, value depending on field:\r\n  exif.exifTagTypes[7] = exif.exifTagTypes[1]\r\n\r\n  exif.getExifValue = function (\r\n    dataView,\r\n    tiffOffset,\r\n    offset,\r\n    type,\r\n    length,\r\n    littleEndian\r\n  ) {\r\n    var tagType = exif.exifTagTypes[type]\r\n    var tagSize\r\n    var dataOffset\r\n    var values\r\n    var i\r\n    var str\r\n    var c\r\n    if (!tagType) {\r\n      console.log('Invalid Exif data: Invalid tag type.')\r\n      return\r\n    }\r\n    tagSize = tagType.size * length\r\n    // Determine if the value is contained in the dataOffset bytes,\r\n    // or if the value at the dataOffset is a pointer to the actual data:\r\n    dataOffset =\r\n      tagSize > 4\r\n        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)\r\n        : offset + 8\r\n    if (dataOffset + tagSize > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid data offset.')\r\n      return\r\n    }\r\n    if (length === 1) {\r\n      return tagType.getValue(dataView, dataOffset, littleEndian)\r\n    }\r\n    values = []\r\n    for (i = 0; i < length; i += 1) {\r\n      values[i] = tagType.getValue(\r\n        dataView,\r\n        dataOffset + i * tagType.size,\r\n        littleEndian\r\n      )\r\n    }\r\n    if (tagType.ascii) {\r\n      str = ''\r\n      // Concatenate the chars:\r\n      for (i = 0; i < values.length; i += 1) {\r\n        c = values[i]\r\n        // Ignore the terminating NULL byte(s):\r\n        if (c === '\\u0000') {\r\n          break\r\n        }\r\n        str += c\r\n      }\r\n      return str\r\n    }\r\n    return values\r\n  }\r\n\r\n  exif.parseExifTag = function (\r\n    dataView,\r\n    tiffOffset,\r\n    offset,\r\n    littleEndian,\r\n    data\r\n  ) {\r\n    var tag = dataView.getUint16(offset, littleEndian)\r\n    data.exif[tag] = exif.getExifValue(\r\n      dataView,\r\n      tiffOffset,\r\n      offset,\r\n      dataView.getUint16(offset + 2, littleEndian), // tag type\r\n      dataView.getUint32(offset + 4, littleEndian), // tag length\r\n      littleEndian\r\n    )\r\n  }\r\n\r\n  exif.parseExifTags = function (\r\n    dataView,\r\n    tiffOffset,\r\n    dirOffset,\r\n    littleEndian,\r\n    data\r\n  ) {\r\n    var tagsNumber, dirEndOffset, i\r\n    if (dirOffset + 6 > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid directory offset.')\r\n      return\r\n    }\r\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian)\r\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber\r\n    if (dirEndOffset + 4 > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid directory size.')\r\n      return\r\n    }\r\n    for (i = 0; i < tagsNumber; i += 1) {\r\n      this.parseExifTag(\r\n        dataView,\r\n        tiffOffset,\r\n        dirOffset + 2 + 12 * i, // tag offset\r\n        littleEndian,\r\n        data\r\n      )\r\n    }\r\n    // Return the offset to the next directory:\r\n    return dataView.getUint32(dirEndOffset, littleEndian)\r\n  }\r\n\r\n  exif.parseExifData = function (dataView, offset, length, data, options) {\r\n    if (options.disableExif) {\r\n      return\r\n    }\r\n    var tiffOffset = offset + 10\r\n    var littleEndian\r\n    var dirOffset\r\n    var thumbnailData\r\n    // Check for the ASCII code for \"Exif\" (0x45786966):\r\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\r\n      // No Exif data, might be XMP data instead\r\n      return\r\n    }\r\n    if (tiffOffset + 8 > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid segment size.')\r\n      return\r\n    }\r\n    // Check for the two null bytes:\r\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\r\n      console.log('Invalid Exif data: Missing byte alignment offset.')\r\n      return\r\n    }\r\n    // Check the byte alignment:\r\n    switch (dataView.getUint16(tiffOffset)) {\r\n      case 0x4949:\r\n        littleEndian = true\r\n        break\r\n      case 0x4d4d:\r\n        littleEndian = false\r\n        break\r\n      default:\r\n        console.log('Invalid Exif data: Invalid byte alignment marker.')\r\n        return\r\n    }\r\n    // Check for the TIFF tag marker (0x002A):\r\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\r\n      console.log('Invalid Exif data: Missing TIFF marker.')\r\n      return\r\n    }\r\n    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\r\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)\r\n    // Create the exif object to store the tags:\r\n    data.exif = new exif.ExifMap()\r\n    // Parse the tags of the main image directory and retrieve the\r\n    // offset to the next directory, usually the thumbnail directory:\r\n    dirOffset = exif.parseExifTags(\r\n      dataView,\r\n      tiffOffset,\r\n      tiffOffset + dirOffset,\r\n      littleEndian,\r\n      data\r\n    )\r\n    if (dirOffset && !options.disableExifThumbnail) {\r\n      thumbnailData = { exif: {} }\r\n      dirOffset = exif.parseExifTags(\r\n        dataView,\r\n        tiffOffset,\r\n        tiffOffset + dirOffset,\r\n        littleEndian,\r\n        thumbnailData\r\n      )\r\n      // Check for JPEG Thumbnail offset:\r\n      if (thumbnailData.exif[0x0201]) {\r\n        data.exif.Thumbnail = exif.getExifThumbnail(\r\n          dataView,\r\n          tiffOffset + thumbnailData.exif[0x0201],\r\n          thumbnailData.exif[0x0202] // Thumbnail data length\r\n        )\r\n      }\r\n    }\r\n    // Check for Exif Sub IFD Pointer:\r\n    if (data.exif[0x8769] && !options.disableExifSub) {\r\n      exif.parseExifTags(\r\n        dataView,\r\n        tiffOffset,\r\n        tiffOffset + data.exif[0x8769], // directory offset\r\n        littleEndian,\r\n        data\r\n      )\r\n    }\r\n    // Check for GPS Info IFD Pointer:\r\n    if (data.exif[0x8825] && !options.disableExifGps) {\r\n      exif.parseExifTags(\r\n        dataView,\r\n        tiffOffset,\r\n        tiffOffset + data.exif[0x8825], // directory offset\r\n        littleEndian,\r\n        data\r\n      )\r\n    }\r\n  }\r\n\r\n  // Registers the Exif parser for the APP1 JPEG meta data segment:\r\n  meta.metaDataParsers.jpeg[0xffe1].push(exif.parseExifData)\r\n\r\n  // Adds the following properties to the parseMetaData callback data:\r\n  // * exif: The exif tags, parsed by the parseExifData method\r\n\r\n  // Adds the following options to the parseMetaData method:\r\n  // * disableExif: Disables Exif parsing.\r\n  // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.\r\n  // * disableExifSub: Disables parsing of the Exif Sub IFD.\r\n  // * disableExifGps: Disables parsing of the Exif GPS Info IFD.\r\n\r\n  return imagex.exif = exif;\r\n\r\n});\ndefine('skylark-graphics-image/scale',[\r\n  \"./imagex\"\r\n], function(imagex) {\r\n   //The module code is based from blueimp/JavaScript-Load-Image\r\n   // original : https://github.com/blueimp/JavaScript-Load-Image/blob/master/js/load-image-scale.js\r\n   // license  : MIT\r\n\r\n  'use strict'\r\n\r\n  // Transform image coordinates, allows to override e.g.\r\n  // the canvas orientation based on the orientation option,\r\n  // gets canvas, options passed as arguments:\r\n  function transformCoordinates() {\r\n\r\n  }\r\n\r\n  // Returns transformed options, allows to override e.g.\r\n  // maxWidth, maxHeight and crop options based on the aspectRatio.\r\n  // gets img, options passed as arguments:\r\n  function getTransformedOptions(img, options) {\r\n    var aspectRatio = options.aspectRatio\r\n    var newOptions\r\n    var i\r\n    var width\r\n    var height\r\n    if (!aspectRatio) {\r\n      return options\r\n    }\r\n    newOptions = {}\r\n    for (i in options) {\r\n      if (options.hasOwnProperty(i)) {\r\n        newOptions[i] = options[i]\r\n      }\r\n    }\r\n    newOptions.crop = true\r\n    width = img.naturalWidth || img.width\r\n    height = img.naturalHeight || img.height\r\n    if (width / height > aspectRatio) {\r\n      newOptions.maxWidth = height * aspectRatio\r\n      newOptions.maxHeight = height\r\n    } else {\r\n      newOptions.maxWidth = width\r\n      newOptions.maxHeight = width / aspectRatio\r\n    }\r\n    return newOptions\r\n  }\r\n\r\n  // Canvas render method, allows to implement a different rendering algorithm:\r\n  function renderImageToCanvas(\r\n    canvas,\r\n    img,\r\n    sourceX,\r\n    sourceY,\r\n    sourceWidth,\r\n    sourceHeight,\r\n    destX,\r\n    destY,\r\n    destWidth,\r\n    destHeight\r\n  ) {\r\n    canvas\r\n      .getContext('2d')\r\n      .drawImage(\r\n        img,\r\n        sourceX,\r\n        sourceY,\r\n        sourceWidth,\r\n        sourceHeight,\r\n        destX,\r\n        destY,\r\n        destWidth,\r\n        destHeight\r\n      )\r\n    return canvas\r\n  }\r\n\r\n  // Determines if the target image should be a canvas element:\r\n  function hasCanvasOption(options) {\r\n    return options.canvas || options.crop || !!options.aspectRatio\r\n  }\r\n\r\n  // Scales and/or crops the given image (img or canvas HTML element)\r\n  // using the given options.\r\n  // Returns a canvas object if the browser supports canvas\r\n  // and the hasCanvasOption method returns true or a canvas\r\n  // object is passed as image, else the scaled image:\r\n   function scale(img, options, data) {\r\n    options = options || {}\r\n    var canvas = document.createElement('canvas')\r\n    var useCanvas =\r\n      img.getContext ||\r\n      (hasCanvasOption(options) && canvas.getContext)\r\n    var width = img.naturalWidth || img.width;\r\n    var height = img.naturalHeight || img.height;\r\n    var destWidth = width;\r\n    var destHeight = height;\r\n    var maxWidth\r\n    var maxHeight\r\n    var minWidth\r\n    var minHeight\r\n    var sourceWidth\r\n    var sourceHeight\r\n    var sourceX\r\n    var sourceY\r\n    var pixelRatio\r\n    var downsamplingRatio\r\n    var tmp\r\n    function scaleUp () {\r\n      var scale = Math.max(\r\n        (minWidth || destWidth) / destWidth,\r\n        (minHeight || destHeight) / destHeight\r\n      )\r\n      if (scale > 1) {\r\n        destWidth *= scale\r\n        destHeight *= scale\r\n      }\r\n    }\r\n    function scaleDown () {\r\n      var scale = Math.min(\r\n        (maxWidth || destWidth) / destWidth,\r\n        (maxHeight || destHeight) / destHeight\r\n      )\r\n      if (scale < 1) {\r\n        destWidth *= scale\r\n        destHeight *= scale\r\n      }\r\n    }\r\n    if (useCanvas) {\r\n      options = getTransformedOptions(img, options, data)\r\n      sourceX = options.left || 0\r\n      sourceY = options.top || 0\r\n      if (options.sourceWidth) {\r\n        sourceWidth = options.sourceWidth\r\n        if (options.right !== undefined && options.left === undefined) {\r\n          sourceX = width - sourceWidth - options.right\r\n        }\r\n      } else {\r\n        sourceWidth = width - sourceX - (options.right || 0)\r\n      }\r\n      if (options.sourceHeight) {\r\n        sourceHeight = options.sourceHeight\r\n        if (options.bottom !== undefined && options.top === undefined) {\r\n          sourceY = height - sourceHeight - options.bottom\r\n        }\r\n      } else {\r\n        sourceHeight = height - sourceY - (options.bottom || 0)\r\n      }\r\n      destWidth = sourceWidth\r\n      destHeight = sourceHeight\r\n    }\r\n    maxWidth = options.maxWidth\r\n    maxHeight = options.maxHeight\r\n    minWidth = options.minWidth\r\n    minHeight = options.minHeight\r\n    if (useCanvas && maxWidth && maxHeight && options.crop) {\r\n      destWidth = maxWidth\r\n      destHeight = maxHeight\r\n      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight\r\n      if (tmp < 0) {\r\n        sourceHeight = maxHeight * sourceWidth / maxWidth\r\n        if (options.top === undefined && options.bottom === undefined) {\r\n          sourceY = (height - sourceHeight) / 2\r\n        }\r\n      } else if (tmp > 0) {\r\n        sourceWidth = maxWidth * sourceHeight / maxHeight\r\n        if (options.left === undefined && options.right === undefined) {\r\n          sourceX = (width - sourceWidth) / 2\r\n        }\r\n      }\r\n    } else {\r\n      if (options.contain || options.cover) {\r\n        minWidth = maxWidth = maxWidth || minWidth\r\n        minHeight = maxHeight = maxHeight || minHeight\r\n      }\r\n      if (options.cover) {\r\n        scaleDown()\r\n        scaleUp()\r\n      } else {\r\n        scaleUp()\r\n        scaleDown()\r\n      }\r\n    }\r\n    if (useCanvas) {\r\n      pixelRatio = options.pixelRatio\r\n      if (pixelRatio > 1) {\r\n        canvas.style.width = destWidth + 'px'\r\n        canvas.style.height = destHeight + 'px'\r\n        destWidth *= pixelRatio\r\n        destHeight *= pixelRatio\r\n        canvas.getContext('2d').scale(pixelRatio, pixelRatio)\r\n      }\r\n      downsamplingRatio = options.downsamplingRatio\r\n      if (\r\n        downsamplingRatio > 0 &&\r\n        downsamplingRatio < 1 &&\r\n        destWidth < sourceWidth &&\r\n        destHeight < sourceHeight\r\n      ) {\r\n        while (sourceWidth * downsamplingRatio > destWidth) {\r\n          canvas.width = sourceWidth * downsamplingRatio\r\n          canvas.height = sourceHeight * downsamplingRatio\r\n          renderImageToCanvas(\r\n            canvas,\r\n            img,\r\n            sourceX,\r\n            sourceY,\r\n            sourceWidth,\r\n            sourceHeight,\r\n            0,\r\n            0,\r\n            canvas.width,\r\n            canvas.height\r\n          )\r\n          sourceX = 0\r\n          sourceY = 0\r\n          sourceWidth = canvas.width\r\n          sourceHeight = canvas.height\r\n          img = document.createElement('canvas')\r\n          img.width = sourceWidth\r\n          img.height = sourceHeight\r\n          renderImageToCanvas(\r\n            img,\r\n            canvas,\r\n            0,\r\n            0,\r\n            sourceWidth,\r\n            sourceHeight,\r\n            0,\r\n            0,\r\n            sourceWidth,\r\n            sourceHeight\r\n          )\r\n        }\r\n      }\r\n      canvas.width = destWidth\r\n      canvas.height = destHeight\r\n      transformCoordinates(canvas, options)\r\n      return renderImageToCanvas(\r\n        canvas,\r\n        img,\r\n        sourceX,\r\n        sourceY,\r\n        sourceWidth,\r\n        sourceHeight,\r\n        0,\r\n        0,\r\n        destWidth,\r\n        destHeight\r\n      )\r\n    }\r\n    img.width = destWidth\r\n    img.height = destHeight\r\n    return img\r\n  }\r\n\r\n  return imagex.scale = scale;\r\n});\ndefine('skylark-graphics-image/loadFile',[\r\n  \"./imagex\"\r\n], function(imagex) {\r\n\r\n  'use strict'\r\n\r\n  // Loads an image for a given File object.\r\n  // Invokes the callback with an img or optional canvas\r\n  // element (if supported by the browser) as parameter:\r\n\r\n  function loadFile (file, callback, options) {\r\n    var img = document.createElement('img')\r\n    var url\r\n    img.onerror = function (event) {\r\n      return imagex.onerror(img, event, file, callback, options)\r\n    }\r\n    img.onload = function (event) {\r\n      return imagex.onload(img, event, file, callback, options)\r\n    }\r\n    if (typeof file === 'string') {\r\n      imagex.fetchBlob(\r\n        file,\r\n        function (blob) {\r\n          if (blob) {\r\n            file = blob\r\n            url = imagex.createObjectURL(file)\r\n          } else {\r\n            url = file\r\n            if (options && options.crossOrigin) {\r\n              img.crossOrigin = options.crossOrigin\r\n            }\r\n          }\r\n          img.src = url\r\n        },\r\n        options\r\n      )\r\n      return img\r\n    } else if (\r\n      imagex.isInstanceOf('Blob', file) ||\r\n      // Files are also Blob instances, but some browsers\r\n      // (Firefox 3.6) support the File API but not Blobs:\r\n      imagex.isInstanceOf('File', file)\r\n    ) {\r\n      url = img._objectURL = imagex.createObjectURL(file)\r\n      if (url) {\r\n        img.src = url\r\n        return img\r\n      }\r\n      return imagex.readFile(file, function (e) {\r\n        var target = e.target\r\n        if (target && target.result) {\r\n          img.src = target.result\r\n        } else if (callback) {\r\n          callback(e)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n\r\n  return imagex.loadFile = loadFile;\r\n\r\n});\ndefine('skylark-graphics-image/main',[\r\n\t\"./imagex\",\r\n\t\"./meta\",\r\n\t\"./exif\",\r\n\t\"./scale\",\r\n\t\"./loadFile\"\r\n],function(imagex){\r\n\treturn imagex;\r\n});\ndefine('skylark-graphics-image', ['skylark-graphics-image/main'], function (main) { return main; });\n\n"]}