{"version":3,"sources":["skylark-graphics-image.js"],"names":["define","skylark","imagex","urlAPI","URL","webkitURL","revokeHelper","img","options","_objectURL","noRevoke","revokeObjectURL","fetchBlob","url","callback","isInstanceOf","type","obj","Object","prototype","toString","call","transform","file","data","onerror","event","onload","createObjectURL","readFile","method","FileReader","fileReader","attach","meta","hasblobSlice","Blob","slice","webkitSlice","mozSlice","blobSlice","this","apply","arguments","metaDataParsers","jpeg","65505","65517","parseMetaData","that","maxMetaDataSize","noMetaData","DataView","size","e","target","error","console","log","markerBytes","markerLength","parsers","i","buffer","result","dataView","offset","maxOffset","byteLength","headLength","getUint16","length","disableImageHead","imageHead","Uint8Array","subarray","hasMetaOption","originalTransform","exif","ExifMap","map","Orientation","get","id","getExifThumbnail","loadImage","exifTagTypes","1","getValue","dataOffset","getUint8","2","String","fromCharCode","ascii","3","littleEndian","4","getUint32","5","9","getInt32","10","getExifValue","tiffOffset","tagSize","values","str","c","tagType","parseExifTag","tag","parseExifTags","dirOffset","tagsNumber","dirEndOffset","parseExifData","disableExif","thumbnailData","disableExifThumbnail","Thumbnail","disableExifSub","disableExifGps","push","renderImageToCanvas","canvas","sourceX","sourceY","sourceWidth","sourceHeight","destX","destY","destWidth","destHeight","getContext","drawImage","scale","maxWidth","maxHeight","minWidth","minHeight","pixelRatio","downsamplingRatio","tmp","document","createElement","useCanvas","crop","aspectRatio","hasCanvasOption","width","naturalWidth","height","naturalHeight","scaleUp","Math","max","scaleDown","min","newOptions","hasOwnProperty","getTransformedOptions","left","top","undefined","right","bottom","contain","cover","style","loadFile","blob","crossOrigin","src","main"],"mappings":"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","file":"../skylark-graphics-image.js","sourcesContent":["define('skylark-graphics-image/image',[\r\n\t\"skylark-langx/skylark\"\r\n],function(skylark){\r\n\r\n\tvar imagex = {};\r\n\r\n\t// The check for URL.revokeObjectURL fixes an issue with Opera 12,\r\n\t// which provides URL.createObjectURL but doesn't properly implement it:\r\n\tvar urlAPI = URL || webkitURL;\r\n\r\n\tfunction revokeHelper (img, options) {\r\n\t\tif (img._objectURL && !(options && options.noRevoke)) {\r\n\t\t  imagex.revokeObjectURL(img._objectURL)\r\n\t\t  delete img._objectURL\r\n\t\t}\r\n\t}\r\n\r\n\t// If the callback given to this function returns a blob, it is used as image\r\n\t// source instead of the original url and overrides the file argument used in\r\n\t// the onload and onerror event callbacks:\r\n\timagex.fetchBlob = function (url, callback, options) {\r\n\t\tcallback();\r\n\t}\r\n\r\n\timagex.isInstanceOf = function (type, obj) {\r\n\t\t// Cross-frame instanceof check\r\n\t\treturn Object.prototype.toString.call(obj) === '[object ' + type + ']'\r\n\t}\r\n\r\n\timagex.transform = function (img, options, callback, file, data) {\r\n\t\tcallback(img, data)\r\n\t}\r\n\r\n\timagex.onerror = function (img, event, file, callback, options) {\r\n\t\trevokeHelper(img, options)\r\n\t\tif (callback) {\r\n\t\t  callback.call(img, event)\r\n\t\t}\r\n\t}\r\n\r\n\timagex.onload = function (img, event, file, callback, options) {\r\n\t\trevokeHelper(img, options)\r\n\t\tif (callback) {\r\n\t\t  imagex.transform(img, options, callback, file, {})\r\n\t\t}\r\n\t}\r\n\r\n\timagex.createObjectURL = function (file) {\r\n\t\treturn urlAPI ? urlAPI.createObjectURL(file) : false\r\n\t}\r\n\r\n\timagex.revokeObjectURL = function (url) {\r\n\t\treturn urlAPI ? urlAPI.revokeObjectURL(url) : false\r\n\t}\r\n\r\n\t// Loads a given File object via FileReader interface,\r\n\t// invokes the callback with the event object (load or error).\r\n\t// The result can be read via event.target.result:\r\n\timagex.readFile = function (file, callback, method) {\r\n\t\tif (FileReader) {\r\n\t\t  var fileReader = new FileReader()\r\n\t\t  fileReader.onload = fileReader.onerror = callback\r\n\t\t  method = method || 'readAsDataURL'\r\n\t\t  if (fileReader[method]) {\r\n\t\t    fileReader[method](file)\r\n\t\t    return fileReader\r\n\t\t  }\r\n\t\t}\r\n\t\treturn false\r\n\t}\r\n\t\r\n\treturn skylark.attach(\"graphics.image\", imagex);\r\n});\ndefine('skylark-graphics-image/meta',[\r\n  \"./image\",\r\n], function(imagex) {\r\n  'use strict'\r\n\r\n  var meta = {};\r\n\r\n  var hasblobSlice =\r\n    typeof Blob !== 'undefined' &&\r\n    (Blob.prototype.slice ||\r\n      Blob.prototype.webkitSlice ||\r\n      Blob.prototype.mozSlice)\r\n\r\n  imagex.blobSlice =\r\n    hasblobSlice &&\r\n    function () {\r\n      var slice = this.slice || this.webkitSlice || this.mozSlice\r\n      return slice.apply(this, arguments)\r\n    }\r\n\r\n  meta.metaDataParsers = {\r\n    jpeg: {\r\n      0xffe1: [], // APP1 marker\r\n      0xffed: [] // APP13 marker\r\n    }\r\n  }\r\n\r\n  // Parses image meta data and calls the callback with an object argument\r\n  // with the following properties:\r\n  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\r\n  // The options argument accepts an object and supports the following\r\n  // properties:\r\n  // * maxMetaDataSize: Defines the maximum number of bytes to parse.\r\n  // * disableImageHead: Disables creating the imageHead property.\r\n  meta.parseMetaData = function (file, callback, options, data) {\r\n    options = options || {}\r\n    data = data || {}\r\n    var that = this\r\n    // 256 KiB should contain all EXIF/ICC/IPTC segments:\r\n    var maxMetaDataSize = options.maxMetaDataSize || 262144\r\n    var noMetaData = !(\r\n      typeof DataView !== 'undefined' &&\r\n      file &&\r\n      file.size >= 12 &&\r\n      file.type === 'image/jpeg' &&\r\n      imagex.blobSlice\r\n    )\r\n    if (\r\n      noMetaData ||\r\n      !imagex.readFile(\r\n        imagex.blobSlice.call(file, 0, maxMetaDataSize),\r\n        function (e) {\r\n          if (e.target.error) {\r\n            // FileReader error\r\n            console.log(e.target.error)\r\n            callback(data)\r\n            return\r\n          }\r\n          // Note on endianness:\r\n          // Since the marker and length bytes in JPEG files are always\r\n          // stored in big endian order, we can leave the endian parameter\r\n          // of the DataView methods undefined, defaulting to big endian.\r\n          var buffer = e.target.result\r\n          var dataView = new DataView(buffer)\r\n          var offset = 2\r\n          var maxOffset = dataView.byteLength - 4\r\n          var headLength = offset\r\n          var markerBytes\r\n          var markerLength\r\n          var parsers\r\n          var i\r\n          // Check for the JPEG marker (0xffd8):\r\n          if (dataView.getUint16(0) === 0xffd8) {\r\n            while (offset < maxOffset) {\r\n              markerBytes = dataView.getUint16(offset)\r\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\r\n              // which contain application-specific meta-data like\r\n              // Exif, ICC and IPTC data and text comments:\r\n              if (\r\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\r\n                markerBytes === 0xfffe\r\n              ) {\r\n                // The marker bytes (2) are always followed by\r\n                // the length bytes (2), indicating the length of the\r\n                // marker segment, which includes the length bytes,\r\n                // but not the marker bytes, so we add 2:\r\n                markerLength = dataView.getUint16(offset + 2) + 2\r\n                if (offset + markerLength > dataView.byteLength) {\r\n                  console.log('Invalid meta data: Invalid segment size.')\r\n                  break\r\n                }\r\n                parsers = meta.metaDataParsers.jpeg[markerBytes]\r\n                if (parsers) {\r\n                  for (i = 0; i < parsers.length; i += 1) {\r\n                    parsers[i].call(\r\n                      that,\r\n                      dataView,\r\n                      offset,\r\n                      markerLength,\r\n                      data,\r\n                      options\r\n                    )\r\n                  }\r\n                }\r\n                offset += markerLength\r\n                headLength = offset\r\n              } else {\r\n                // Not an APPn or COM marker, probably safe to\r\n                // assume that this is the end of the meta data\r\n                break\r\n              }\r\n            }\r\n            // Meta length must be longer than JPEG marker (2)\r\n            // plus APPn marker (2), followed by length bytes (2):\r\n            if (!options.disableImageHead && headLength > 6) {\r\n              if (buffer.slice) {\r\n                data.imageHead = buffer.slice(0, headLength)\r\n              } else {\r\n                // Workaround for IE10, which does not yet\r\n                // support ArrayBuffer.slice:\r\n                data.imageHead = new Uint8Array(buffer).subarray(0, headLength)\r\n              }\r\n            }\r\n          } else {\r\n            console.log('Invalid JPEG file: Missing JPEG marker.')\r\n          }\r\n          callback(data)\r\n        },\r\n        'readAsArrayBuffer'\r\n      )\r\n    ) {\r\n      callback(data)\r\n    }\r\n  }\r\n\r\n  // Determines if meta data should be loaded automatically:\r\n  meta.hasMetaOption = function (options) {\r\n    return options && options.meta\r\n  }\r\n\r\n  var originalTransform = imagex.transform\r\n  imagex.transform = function (img, options, callback, file, data) {\r\n    if (meta.hasMetaOption(options)) {\r\n      meta.parseMetaData(\r\n        file,\r\n        function (data) {\r\n          originalTransform.call(imagex, img, options, callback, file, data)\r\n        },\r\n        options,\r\n        data\r\n      )\r\n    } else {\r\n      originalTransform.apply(imagex, arguments)\r\n    }\r\n  }\r\n\r\n  return imagex.meta = meta;\r\n});\ndefine('skylark-graphics-image/exif',[\r\n  \"./image\",\r\n  \"./meta\"\r\n], function(imagex,meta) {\r\n   //The module code is based from blueimp/JavaScript-Load-Image\r\n   // original : https://github.com/blueimp/JavaScript-Load-Image/blob/master/js/load-image-scale.js\r\n   // license  : MIT\r\n\r\n 'use strict'\r\n  var exif = function() {\r\n\r\n  };\r\n\r\n\r\n  exif.ExifMap = function () {\r\n    return this\r\n  }\r\n\r\n  exif.ExifMap.prototype.map = {\r\n    Orientation: 0x0112\r\n  }\r\n\r\n  exif.ExifMap.prototype.get = function (id) {\r\n    return this[id] || this[this.map[id]]\r\n  }\r\n\r\n  exif.getExifThumbnail = function (dataView, offset, length) {\r\n    if (!length || offset + length > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid thumbnail data.')\r\n      return\r\n    }\r\n    return loadImage.createObjectURL(\r\n      new Blob([dataView.buffer.slice(offset, offset + length)])\r\n    )\r\n  }\r\n\r\n  exif.exifTagTypes = {\r\n    // byte, 8-bit unsigned int:\r\n    1: {\r\n      getValue: function (dataView, dataOffset) {\r\n        return dataView.getUint8(dataOffset)\r\n      },\r\n      size: 1\r\n    },\r\n    // ascii, 8-bit byte:\r\n    2: {\r\n      getValue: function (dataView, dataOffset) {\r\n        return String.fromCharCode(dataView.getUint8(dataOffset))\r\n      },\r\n      size: 1,\r\n      ascii: true\r\n    },\r\n    // short, 16 bit int:\r\n    3: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return dataView.getUint16(dataOffset, littleEndian)\r\n      },\r\n      size: 2\r\n    },\r\n    // long, 32 bit int:\r\n    4: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return dataView.getUint32(dataOffset, littleEndian)\r\n      },\r\n      size: 4\r\n    },\r\n    // rational = two long values, first is numerator, second is denominator:\r\n    5: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return (\r\n          dataView.getUint32(dataOffset, littleEndian) /\r\n          dataView.getUint32(dataOffset + 4, littleEndian)\r\n        )\r\n      },\r\n      size: 8\r\n    },\r\n    // slong, 32 bit signed int:\r\n    9: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return dataView.getInt32(dataOffset, littleEndian)\r\n      },\r\n      size: 4\r\n    },\r\n    // srational, two slongs, first is numerator, second is denominator:\r\n    10: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return (\r\n          dataView.getInt32(dataOffset, littleEndian) /\r\n          dataView.getInt32(dataOffset + 4, littleEndian)\r\n        )\r\n      },\r\n      size: 8\r\n    }\r\n  }\r\n  // undefined, 8-bit byte, value depending on field:\r\n  exif.exifTagTypes[7] = exif.exifTagTypes[1]\r\n\r\n  exif.getExifValue = function (\r\n    dataView,\r\n    tiffOffset,\r\n    offset,\r\n    type,\r\n    length,\r\n    littleEndian\r\n  ) {\r\n    var tagType = exif.exifTagTypes[type]\r\n    var tagSize\r\n    var dataOffset\r\n    var values\r\n    var i\r\n    var str\r\n    var c\r\n    if (!tagType) {\r\n      console.log('Invalid Exif data: Invalid tag type.')\r\n      return\r\n    }\r\n    tagSize = tagType.size * length\r\n    // Determine if the value is contained in the dataOffset bytes,\r\n    // or if the value at the dataOffset is a pointer to the actual data:\r\n    dataOffset =\r\n      tagSize > 4\r\n        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)\r\n        : offset + 8\r\n    if (dataOffset + tagSize > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid data offset.')\r\n      return\r\n    }\r\n    if (length === 1) {\r\n      return tagType.getValue(dataView, dataOffset, littleEndian)\r\n    }\r\n    values = []\r\n    for (i = 0; i < length; i += 1) {\r\n      values[i] = tagType.getValue(\r\n        dataView,\r\n        dataOffset + i * tagType.size,\r\n        littleEndian\r\n      )\r\n    }\r\n    if (tagType.ascii) {\r\n      str = ''\r\n      // Concatenate the chars:\r\n      for (i = 0; i < values.length; i += 1) {\r\n        c = values[i]\r\n        // Ignore the terminating NULL byte(s):\r\n        if (c === '\\u0000') {\r\n          break\r\n        }\r\n        str += c\r\n      }\r\n      return str\r\n    }\r\n    return values\r\n  }\r\n\r\n  exif.parseExifTag = function (\r\n    dataView,\r\n    tiffOffset,\r\n    offset,\r\n    littleEndian,\r\n    data\r\n  ) {\r\n    var tag = dataView.getUint16(offset, littleEndian)\r\n    data.exif[tag] = exif.getExifValue(\r\n      dataView,\r\n      tiffOffset,\r\n      offset,\r\n      dataView.getUint16(offset + 2, littleEndian), // tag type\r\n      dataView.getUint32(offset + 4, littleEndian), // tag length\r\n      littleEndian\r\n    )\r\n  }\r\n\r\n  exif.parseExifTags = function (\r\n    dataView,\r\n    tiffOffset,\r\n    dirOffset,\r\n    littleEndian,\r\n    data\r\n  ) {\r\n    var tagsNumber, dirEndOffset, i\r\n    if (dirOffset + 6 > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid directory offset.')\r\n      return\r\n    }\r\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian)\r\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber\r\n    if (dirEndOffset + 4 > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid directory size.')\r\n      return\r\n    }\r\n    for (i = 0; i < tagsNumber; i += 1) {\r\n      this.parseExifTag(\r\n        dataView,\r\n        tiffOffset,\r\n        dirOffset + 2 + 12 * i, // tag offset\r\n        littleEndian,\r\n        data\r\n      )\r\n    }\r\n    // Return the offset to the next directory:\r\n    return dataView.getUint32(dirEndOffset, littleEndian)\r\n  }\r\n\r\n  exif.parseExifData = function (dataView, offset, length, data, options) {\r\n    if (options.disableExif) {\r\n      return\r\n    }\r\n    var tiffOffset = offset + 10\r\n    var littleEndian\r\n    var dirOffset\r\n    var thumbnailData\r\n    // Check for the ASCII code for \"Exif\" (0x45786966):\r\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\r\n      // No Exif data, might be XMP data instead\r\n      return\r\n    }\r\n    if (tiffOffset + 8 > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid segment size.')\r\n      return\r\n    }\r\n    // Check for the two null bytes:\r\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\r\n      console.log('Invalid Exif data: Missing byte alignment offset.')\r\n      return\r\n    }\r\n    // Check the byte alignment:\r\n    switch (dataView.getUint16(tiffOffset)) {\r\n      case 0x4949:\r\n        littleEndian = true\r\n        break\r\n      case 0x4d4d:\r\n        littleEndian = false\r\n        break\r\n      default:\r\n        console.log('Invalid Exif data: Invalid byte alignment marker.')\r\n        return\r\n    }\r\n    // Check for the TIFF tag marker (0x002A):\r\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\r\n      console.log('Invalid Exif data: Missing TIFF marker.')\r\n      return\r\n    }\r\n    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\r\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)\r\n    // Create the exif object to store the tags:\r\n    data.exif = new exif.ExifMap()\r\n    // Parse the tags of the main image directory and retrieve the\r\n    // offset to the next directory, usually the thumbnail directory:\r\n    dirOffset = exif.parseExifTags(\r\n      dataView,\r\n      tiffOffset,\r\n      tiffOffset + dirOffset,\r\n      littleEndian,\r\n      data\r\n    )\r\n    if (dirOffset && !options.disableExifThumbnail) {\r\n      thumbnailData = { exif: {} }\r\n      dirOffset = exif.parseExifTags(\r\n        dataView,\r\n        tiffOffset,\r\n        tiffOffset + dirOffset,\r\n        littleEndian,\r\n        thumbnailData\r\n      )\r\n      // Check for JPEG Thumbnail offset:\r\n      if (thumbnailData.exif[0x0201]) {\r\n        data.exif.Thumbnail = exif.getExifThumbnail(\r\n          dataView,\r\n          tiffOffset + thumbnailData.exif[0x0201],\r\n          thumbnailData.exif[0x0202] // Thumbnail data length\r\n        )\r\n      }\r\n    }\r\n    // Check for Exif Sub IFD Pointer:\r\n    if (data.exif[0x8769] && !options.disableExifSub) {\r\n      exif.parseExifTags(\r\n        dataView,\r\n        tiffOffset,\r\n        tiffOffset + data.exif[0x8769], // directory offset\r\n        littleEndian,\r\n        data\r\n      )\r\n    }\r\n    // Check for GPS Info IFD Pointer:\r\n    if (data.exif[0x8825] && !options.disableExifGps) {\r\n      exif.parseExifTags(\r\n        dataView,\r\n        tiffOffset,\r\n        tiffOffset + data.exif[0x8825], // directory offset\r\n        littleEndian,\r\n        data\r\n      )\r\n    }\r\n  }\r\n\r\n  // Registers the Exif parser for the APP1 JPEG meta data segment:\r\n  meta.metaDataParsers.jpeg[0xffe1].push(exif.parseExifData)\r\n\r\n  // Adds the following properties to the parseMetaData callback data:\r\n  // * exif: The exif tags, parsed by the parseExifData method\r\n\r\n  // Adds the following options to the parseMetaData method:\r\n  // * disableExif: Disables Exif parsing.\r\n  // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.\r\n  // * disableExifSub: Disables parsing of the Exif Sub IFD.\r\n  // * disableExifGps: Disables parsing of the Exif GPS Info IFD.\r\n\r\n  return imagex.exif = exif;\r\n\r\n});\ndefine('skylark-graphics-image/scale',[\r\n  \"./image\"\r\n], function(imagex) {\r\n   //The module code is based from blueimp/JavaScript-Load-Image\r\n   // original : https://github.com/blueimp/JavaScript-Load-Image/blob/master/js/load-image-scale.js\r\n   // license  : MIT\r\n\r\n  'use strict'\r\n\r\n  // Transform image coordinates, allows to override e.g.\r\n  // the canvas orientation based on the orientation option,\r\n  // gets canvas, options passed as arguments:\r\n  function transformCoordinates() {\r\n\r\n  }\r\n\r\n  // Returns transformed options, allows to override e.g.\r\n  // maxWidth, maxHeight and crop options based on the aspectRatio.\r\n  // gets img, options passed as arguments:\r\n  function getTransformedOptions(img, options) {\r\n    var aspectRatio = options.aspectRatio\r\n    var newOptions\r\n    var i\r\n    var width\r\n    var height\r\n    if (!aspectRatio) {\r\n      return options\r\n    }\r\n    newOptions = {}\r\n    for (i in options) {\r\n      if (options.hasOwnProperty(i)) {\r\n        newOptions[i] = options[i]\r\n      }\r\n    }\r\n    newOptions.crop = true\r\n    width = img.naturalWidth || img.width\r\n    height = img.naturalHeight || img.height\r\n    if (width / height > aspectRatio) {\r\n      newOptions.maxWidth = height * aspectRatio\r\n      newOptions.maxHeight = height\r\n    } else {\r\n      newOptions.maxWidth = width\r\n      newOptions.maxHeight = width / aspectRatio\r\n    }\r\n    return newOptions\r\n  }\r\n\r\n  // Canvas render method, allows to implement a different rendering algorithm:\r\n  function renderImageToCanvas(\r\n    canvas,\r\n    img,\r\n    sourceX,\r\n    sourceY,\r\n    sourceWidth,\r\n    sourceHeight,\r\n    destX,\r\n    destY,\r\n    destWidth,\r\n    destHeight\r\n  ) {\r\n    canvas\r\n      .getContext('2d')\r\n      .drawImage(\r\n        img,\r\n        sourceX,\r\n        sourceY,\r\n        sourceWidth,\r\n        sourceHeight,\r\n        destX,\r\n        destY,\r\n        destWidth,\r\n        destHeight\r\n      )\r\n    return canvas\r\n  }\r\n\r\n  // Determines if the target image should be a canvas element:\r\n  function hasCanvasOption(options) {\r\n    return options.canvas || options.crop || !!options.aspectRatio\r\n  }\r\n\r\n  // Scales and/or crops the given image (img or canvas HTML element)\r\n  // using the given options.\r\n  // Returns a canvas object if the browser supports canvas\r\n  // and the hasCanvasOption method returns true or a canvas\r\n  // object is passed as image, else the scaled image:\r\n   function scale(img, options, data) {\r\n    options = options || {}\r\n    var canvas = document.createElement('canvas')\r\n    var useCanvas =\r\n      img.getContext ||\r\n      (hasCanvasOption(options) && canvas.getContext)\r\n    var width = img.naturalWidth || img.width;\r\n    var height = img.naturalHeight || img.height;\r\n    var destWidth = width;\r\n    var destHeight = height;\r\n    var maxWidth\r\n    var maxHeight\r\n    var minWidth\r\n    var minHeight\r\n    var sourceWidth\r\n    var sourceHeight\r\n    var sourceX\r\n    var sourceY\r\n    var pixelRatio\r\n    var downsamplingRatio\r\n    var tmp\r\n    function scaleUp () {\r\n      var scale = Math.max(\r\n        (minWidth || destWidth) / destWidth,\r\n        (minHeight || destHeight) / destHeight\r\n      )\r\n      if (scale > 1) {\r\n        destWidth *= scale\r\n        destHeight *= scale\r\n      }\r\n    }\r\n    function scaleDown () {\r\n      var scale = Math.min(\r\n        (maxWidth || destWidth) / destWidth,\r\n        (maxHeight || destHeight) / destHeight\r\n      )\r\n      if (scale < 1) {\r\n        destWidth *= scale\r\n        destHeight *= scale\r\n      }\r\n    }\r\n    if (useCanvas) {\r\n      options = getTransformedOptions(img, options, data)\r\n      sourceX = options.left || 0\r\n      sourceY = options.top || 0\r\n      if (options.sourceWidth) {\r\n        sourceWidth = options.sourceWidth\r\n        if (options.right !== undefined && options.left === undefined) {\r\n          sourceX = width - sourceWidth - options.right\r\n        }\r\n      } else {\r\n        sourceWidth = width - sourceX - (options.right || 0)\r\n      }\r\n      if (options.sourceHeight) {\r\n        sourceHeight = options.sourceHeight\r\n        if (options.bottom !== undefined && options.top === undefined) {\r\n          sourceY = height - sourceHeight - options.bottom\r\n        }\r\n      } else {\r\n        sourceHeight = height - sourceY - (options.bottom || 0)\r\n      }\r\n      destWidth = sourceWidth\r\n      destHeight = sourceHeight\r\n    }\r\n    maxWidth = options.maxWidth\r\n    maxHeight = options.maxHeight\r\n    minWidth = options.minWidth\r\n    minHeight = options.minHeight\r\n    if (useCanvas && maxWidth && maxHeight && options.crop) {\r\n      destWidth = maxWidth\r\n      destHeight = maxHeight\r\n      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight\r\n      if (tmp < 0) {\r\n        sourceHeight = maxHeight * sourceWidth / maxWidth\r\n        if (options.top === undefined && options.bottom === undefined) {\r\n          sourceY = (height - sourceHeight) / 2\r\n        }\r\n      } else if (tmp > 0) {\r\n        sourceWidth = maxWidth * sourceHeight / maxHeight\r\n        if (options.left === undefined && options.right === undefined) {\r\n          sourceX = (width - sourceWidth) / 2\r\n        }\r\n      }\r\n    } else {\r\n      if (options.contain || options.cover) {\r\n        minWidth = maxWidth = maxWidth || minWidth\r\n        minHeight = maxHeight = maxHeight || minHeight\r\n      }\r\n      if (options.cover) {\r\n        scaleDown()\r\n        scaleUp()\r\n      } else {\r\n        scaleUp()\r\n        scaleDown()\r\n      }\r\n    }\r\n    if (useCanvas) {\r\n      pixelRatio = options.pixelRatio\r\n      if (pixelRatio > 1) {\r\n        canvas.style.width = destWidth + 'px'\r\n        canvas.style.height = destHeight + 'px'\r\n        destWidth *= pixelRatio\r\n        destHeight *= pixelRatio\r\n        canvas.getContext('2d').scale(pixelRatio, pixelRatio)\r\n      }\r\n      downsamplingRatio = options.downsamplingRatio\r\n      if (\r\n        downsamplingRatio > 0 &&\r\n        downsamplingRatio < 1 &&\r\n        destWidth < sourceWidth &&\r\n        destHeight < sourceHeight\r\n      ) {\r\n        while (sourceWidth * downsamplingRatio > destWidth) {\r\n          canvas.width = sourceWidth * downsamplingRatio\r\n          canvas.height = sourceHeight * downsamplingRatio\r\n          renderImageToCanvas(\r\n            canvas,\r\n            img,\r\n            sourceX,\r\n            sourceY,\r\n            sourceWidth,\r\n            sourceHeight,\r\n            0,\r\n            0,\r\n            canvas.width,\r\n            canvas.height\r\n          )\r\n          sourceX = 0\r\n          sourceY = 0\r\n          sourceWidth = canvas.width\r\n          sourceHeight = canvas.height\r\n          img = document.createElement('canvas')\r\n          img.width = sourceWidth\r\n          img.height = sourceHeight\r\n          renderImageToCanvas(\r\n            img,\r\n            canvas,\r\n            0,\r\n            0,\r\n            sourceWidth,\r\n            sourceHeight,\r\n            0,\r\n            0,\r\n            sourceWidth,\r\n            sourceHeight\r\n          )\r\n        }\r\n      }\r\n      canvas.width = destWidth\r\n      canvas.height = destHeight\r\n      transformCoordinates(canvas, options)\r\n      return renderImageToCanvas(\r\n        canvas,\r\n        img,\r\n        sourceX,\r\n        sourceY,\r\n        sourceWidth,\r\n        sourceHeight,\r\n        0,\r\n        0,\r\n        destWidth,\r\n        destHeight\r\n      )\r\n    }\r\n    img.width = destWidth\r\n    img.height = destHeight\r\n    return img\r\n  }\r\n\r\n  return imagex.scale = scale;\r\n});\ndefine('skylark-graphics-image/loadFile',[\r\n  \"./image\"\r\n], function(imagex) {\r\n\r\n  'use strict'\r\n\r\n  // Loads an image for a given File object.\r\n  // Invokes the callback with an img or optional canvas\r\n  // element (if supported by the browser) as parameter:\r\n\r\n  function loadFile (file, callback, options) {\r\n    var img = document.createElement('img')\r\n    var url\r\n    img.onerror = function (event) {\r\n      return imagex.onerror(img, event, file, callback, options)\r\n    }\r\n    img.onload = function (event) {\r\n      return imagex.onload(img, event, file, callback, options)\r\n    }\r\n    if (typeof file === 'string') {\r\n      imagex.fetchBlob(\r\n        file,\r\n        function (blob) {\r\n          if (blob) {\r\n            file = blob\r\n            url = imagex.createObjectURL(file)\r\n          } else {\r\n            url = file\r\n            if (options && options.crossOrigin) {\r\n              img.crossOrigin = options.crossOrigin\r\n            }\r\n          }\r\n          img.src = url\r\n        },\r\n        options\r\n      )\r\n      return img\r\n    } else if (\r\n      imagex.isInstanceOf('Blob', file) ||\r\n      // Files are also Blob instances, but some browsers\r\n      // (Firefox 3.6) support the File API but not Blobs:\r\n      imagex.isInstanceOf('File', file)\r\n    ) {\r\n      url = img._objectURL = imagex.createObjectURL(file)\r\n      if (url) {\r\n        img.src = url\r\n        return img\r\n      }\r\n      return imagex.readFile(file, function (e) {\r\n        var target = e.target\r\n        if (target && target.result) {\r\n          img.src = target.result\r\n        } else if (callback) {\r\n          callback(e)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n\r\n  return imagex.loadFile = loadFile;\r\n\r\n});\ndefine('skylark-graphics-image/main',[\r\n\t\"./image\",\r\n\t\"./meta\",\r\n\t\"./exif\",\r\n\t\"./scale\",\r\n\t\"./loadFile\"\r\n],function(imagex){\r\n\treturn imagex;\r\n});\ndefine('skylark-graphics-image', ['skylark-graphics-image/main'], function (main) { return main; });\n\n"]}