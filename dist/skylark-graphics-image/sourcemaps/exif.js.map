{"version":3,"sources":["exif.js"],"names":["define","imagex","meta","exif","ExifMap","this","prototype","map","Orientation","get","id","getExifThumbnail","dataView","offset","length","byteLength","loadImage","createObjectURL","Blob","buffer","slice","console","log","exifTagTypes","1","getValue","dataOffset","getUint8","size","2","String","fromCharCode","ascii","3","littleEndian","getUint16","4","getUint32","5","9","getInt32","10","getExifValue","tiffOffset","type","tagSize","values","i","str","c","tagType","parseExifTag","data","tag","parseExifTags","dirOffset","tagsNumber","dirEndOffset","parseExifData","options","disableExif","thumbnailData","disableExifThumbnail","Thumbnail","disableExifSub","disableExifGps","metaDataParsers","jpeg","push"],"mappings":"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","file":"../exif.js","sourcesContent":["define([\r\n  \"./image\",\r\n  \"./meta\"\r\n], function(imagex,meta) {\r\n   //The module code is based from blueimp/JavaScript-Load-Image\r\n   // original : https://github.com/blueimp/JavaScript-Load-Image/blob/master/js/load-image-scale.js\r\n   // license  : MIT\r\n\r\n 'use strict'\r\n  var exif = function() {\r\n\r\n  };\r\n\r\n\r\n  exif.ExifMap = function () {\r\n    return this\r\n  }\r\n\r\n  exif.ExifMap.prototype.map = {\r\n    Orientation: 0x0112\r\n  }\r\n\r\n  exif.ExifMap.prototype.get = function (id) {\r\n    return this[id] || this[this.map[id]]\r\n  }\r\n\r\n  exif.getExifThumbnail = function (dataView, offset, length) {\r\n    if (!length || offset + length > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid thumbnail data.')\r\n      return\r\n    }\r\n    return loadImage.createObjectURL(\r\n      new Blob([dataView.buffer.slice(offset, offset + length)])\r\n    )\r\n  }\r\n\r\n  exif.exifTagTypes = {\r\n    // byte, 8-bit unsigned int:\r\n    1: {\r\n      getValue: function (dataView, dataOffset) {\r\n        return dataView.getUint8(dataOffset)\r\n      },\r\n      size: 1\r\n    },\r\n    // ascii, 8-bit byte:\r\n    2: {\r\n      getValue: function (dataView, dataOffset) {\r\n        return String.fromCharCode(dataView.getUint8(dataOffset))\r\n      },\r\n      size: 1,\r\n      ascii: true\r\n    },\r\n    // short, 16 bit int:\r\n    3: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return dataView.getUint16(dataOffset, littleEndian)\r\n      },\r\n      size: 2\r\n    },\r\n    // long, 32 bit int:\r\n    4: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return dataView.getUint32(dataOffset, littleEndian)\r\n      },\r\n      size: 4\r\n    },\r\n    // rational = two long values, first is numerator, second is denominator:\r\n    5: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return (\r\n          dataView.getUint32(dataOffset, littleEndian) /\r\n          dataView.getUint32(dataOffset + 4, littleEndian)\r\n        )\r\n      },\r\n      size: 8\r\n    },\r\n    // slong, 32 bit signed int:\r\n    9: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return dataView.getInt32(dataOffset, littleEndian)\r\n      },\r\n      size: 4\r\n    },\r\n    // srational, two slongs, first is numerator, second is denominator:\r\n    10: {\r\n      getValue: function (dataView, dataOffset, littleEndian) {\r\n        return (\r\n          dataView.getInt32(dataOffset, littleEndian) /\r\n          dataView.getInt32(dataOffset + 4, littleEndian)\r\n        )\r\n      },\r\n      size: 8\r\n    }\r\n  }\r\n  // undefined, 8-bit byte, value depending on field:\r\n  exif.exifTagTypes[7] = exif.exifTagTypes[1]\r\n\r\n  exif.getExifValue = function (\r\n    dataView,\r\n    tiffOffset,\r\n    offset,\r\n    type,\r\n    length,\r\n    littleEndian\r\n  ) {\r\n    var tagType = exif.exifTagTypes[type]\r\n    var tagSize\r\n    var dataOffset\r\n    var values\r\n    var i\r\n    var str\r\n    var c\r\n    if (!tagType) {\r\n      console.log('Invalid Exif data: Invalid tag type.')\r\n      return\r\n    }\r\n    tagSize = tagType.size * length\r\n    // Determine if the value is contained in the dataOffset bytes,\r\n    // or if the value at the dataOffset is a pointer to the actual data:\r\n    dataOffset =\r\n      tagSize > 4\r\n        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)\r\n        : offset + 8\r\n    if (dataOffset + tagSize > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid data offset.')\r\n      return\r\n    }\r\n    if (length === 1) {\r\n      return tagType.getValue(dataView, dataOffset, littleEndian)\r\n    }\r\n    values = []\r\n    for (i = 0; i < length; i += 1) {\r\n      values[i] = tagType.getValue(\r\n        dataView,\r\n        dataOffset + i * tagType.size,\r\n        littleEndian\r\n      )\r\n    }\r\n    if (tagType.ascii) {\r\n      str = ''\r\n      // Concatenate the chars:\r\n      for (i = 0; i < values.length; i += 1) {\r\n        c = values[i]\r\n        // Ignore the terminating NULL byte(s):\r\n        if (c === '\\u0000') {\r\n          break\r\n        }\r\n        str += c\r\n      }\r\n      return str\r\n    }\r\n    return values\r\n  }\r\n\r\n  exif.parseExifTag = function (\r\n    dataView,\r\n    tiffOffset,\r\n    offset,\r\n    littleEndian,\r\n    data\r\n  ) {\r\n    var tag = dataView.getUint16(offset, littleEndian)\r\n    data.exif[tag] = exif.getExifValue(\r\n      dataView,\r\n      tiffOffset,\r\n      offset,\r\n      dataView.getUint16(offset + 2, littleEndian), // tag type\r\n      dataView.getUint32(offset + 4, littleEndian), // tag length\r\n      littleEndian\r\n    )\r\n  }\r\n\r\n  exif.parseExifTags = function (\r\n    dataView,\r\n    tiffOffset,\r\n    dirOffset,\r\n    littleEndian,\r\n    data\r\n  ) {\r\n    var tagsNumber, dirEndOffset, i\r\n    if (dirOffset + 6 > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid directory offset.')\r\n      return\r\n    }\r\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian)\r\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber\r\n    if (dirEndOffset + 4 > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid directory size.')\r\n      return\r\n    }\r\n    for (i = 0; i < tagsNumber; i += 1) {\r\n      this.parseExifTag(\r\n        dataView,\r\n        tiffOffset,\r\n        dirOffset + 2 + 12 * i, // tag offset\r\n        littleEndian,\r\n        data\r\n      )\r\n    }\r\n    // Return the offset to the next directory:\r\n    return dataView.getUint32(dirEndOffset, littleEndian)\r\n  }\r\n\r\n  exif.parseExifData = function (dataView, offset, length, data, options) {\r\n    if (options.disableExif) {\r\n      return\r\n    }\r\n    var tiffOffset = offset + 10\r\n    var littleEndian\r\n    var dirOffset\r\n    var thumbnailData\r\n    // Check for the ASCII code for \"Exif\" (0x45786966):\r\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\r\n      // No Exif data, might be XMP data instead\r\n      return\r\n    }\r\n    if (tiffOffset + 8 > dataView.byteLength) {\r\n      console.log('Invalid Exif data: Invalid segment size.')\r\n      return\r\n    }\r\n    // Check for the two null bytes:\r\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\r\n      console.log('Invalid Exif data: Missing byte alignment offset.')\r\n      return\r\n    }\r\n    // Check the byte alignment:\r\n    switch (dataView.getUint16(tiffOffset)) {\r\n      case 0x4949:\r\n        littleEndian = true\r\n        break\r\n      case 0x4d4d:\r\n        littleEndian = false\r\n        break\r\n      default:\r\n        console.log('Invalid Exif data: Invalid byte alignment marker.')\r\n        return\r\n    }\r\n    // Check for the TIFF tag marker (0x002A):\r\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\r\n      console.log('Invalid Exif data: Missing TIFF marker.')\r\n      return\r\n    }\r\n    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\r\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)\r\n    // Create the exif object to store the tags:\r\n    data.exif = new exif.ExifMap()\r\n    // Parse the tags of the main image directory and retrieve the\r\n    // offset to the next directory, usually the thumbnail directory:\r\n    dirOffset = exif.parseExifTags(\r\n      dataView,\r\n      tiffOffset,\r\n      tiffOffset + dirOffset,\r\n      littleEndian,\r\n      data\r\n    )\r\n    if (dirOffset && !options.disableExifThumbnail) {\r\n      thumbnailData = { exif: {} }\r\n      dirOffset = exif.parseExifTags(\r\n        dataView,\r\n        tiffOffset,\r\n        tiffOffset + dirOffset,\r\n        littleEndian,\r\n        thumbnailData\r\n      )\r\n      // Check for JPEG Thumbnail offset:\r\n      if (thumbnailData.exif[0x0201]) {\r\n        data.exif.Thumbnail = exif.getExifThumbnail(\r\n          dataView,\r\n          tiffOffset + thumbnailData.exif[0x0201],\r\n          thumbnailData.exif[0x0202] // Thumbnail data length\r\n        )\r\n      }\r\n    }\r\n    // Check for Exif Sub IFD Pointer:\r\n    if (data.exif[0x8769] && !options.disableExifSub) {\r\n      exif.parseExifTags(\r\n        dataView,\r\n        tiffOffset,\r\n        tiffOffset + data.exif[0x8769], // directory offset\r\n        littleEndian,\r\n        data\r\n      )\r\n    }\r\n    // Check for GPS Info IFD Pointer:\r\n    if (data.exif[0x8825] && !options.disableExifGps) {\r\n      exif.parseExifTags(\r\n        dataView,\r\n        tiffOffset,\r\n        tiffOffset + data.exif[0x8825], // directory offset\r\n        littleEndian,\r\n        data\r\n      )\r\n    }\r\n  }\r\n\r\n  // Registers the Exif parser for the APP1 JPEG meta data segment:\r\n  meta.metaDataParsers.jpeg[0xffe1].push(exif.parseExifData)\r\n\r\n  // Adds the following properties to the parseMetaData callback data:\r\n  // * exif: The exif tags, parsed by the parseExifData method\r\n\r\n  // Adds the following options to the parseMetaData method:\r\n  // * disableExif: Disables Exif parsing.\r\n  // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.\r\n  // * disableExifSub: Disables parsing of the Exif Sub IFD.\r\n  // * disableExifGps: Disables parsing of the Exif GPS Info IFD.\r\n\r\n  return imagex.exif = exif;\r\n\r\n});"]}