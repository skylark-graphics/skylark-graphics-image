{"version":3,"sources":["image.js"],"names":["define","skylark","imagex","urlAPI","URL","webkitURL","revokeHelper","img","options","_objectURL","noRevoke","revokeObjectURL","fetchBlob","url","callback","isInstanceOf","type","obj","Object","prototype","toString","call","transform","file","data","onerror","event","onload","createObjectURL","readFile","method","FileReader","fileReader","attach"],"mappings":";;;;;;;AAAAA,QACC,yBACC,SAASC,GAEV,IAAIC,KAIAC,EAASC,KAAOC,UAEpB,SAASC,EAAcC,EAAKC,IACvBD,EAAIE,YAAgBD,GAAWA,EAAQE,WACzCR,EAAOS,gBAAgBJ,EAAIE,mBACpBF,EAAIE,YA0Dd,OAnDAP,EAAOU,UAAY,SAAUC,EAAKC,EAAUN,GAC3CM,KAGDZ,EAAOa,aAAe,SAAUC,EAAMC,GAErC,OAAOC,OAAOC,UAAUC,SAASC,KAAKJ,KAAS,WAAaD,EAAO,KAGpEd,EAAOoB,UAAY,SAAUf,EAAKC,EAASM,EAAUS,EAAMC,GAC1DV,EAASP,EAAKiB,IAGftB,EAAOuB,QAAU,SAAUlB,EAAKmB,EAAOH,EAAMT,EAAUN,GACtDF,EAAaC,EAAKC,GACdM,GACFA,EAASO,KAAKd,EAAKmB,IAItBxB,EAAOyB,OAAS,SAAUpB,EAAKmB,EAAOH,EAAMT,EAAUN,GACrDF,EAAaC,EAAKC,GACdM,GACFZ,EAAOoB,UAAUf,EAAKC,EAASM,EAAUS,OAI5CrB,EAAO0B,gBAAkB,SAAUL,GAClC,QAAOpB,GAASA,EAAOyB,gBAAgBL,IAGxCrB,EAAOS,gBAAkB,SAAUE,GAClC,QAAOV,GAASA,EAAOQ,gBAAgBE,IAMxCX,EAAO2B,SAAW,SAAUN,EAAMT,EAAUgB,GAC3C,GAAIC,WAAY,CACd,IAAIC,EAAa,IAAID,WAGrB,GAFAC,EAAWL,OAASK,EAAWP,QAAUX,EAErCkB,EADJF,EAASA,GAAU,iBAGjB,OADAE,EAAWF,GAAQP,GACZS,EAGX,OAAO,GAGD/B,EAAQgC,OAAO,iBAAkB/B","file":"../image.js","sourcesContent":["define([\r\n\t\"skylark-langx/skylark\"\r\n],function(skylark){\r\n\r\n\tvar imagex = {};\r\n\r\n\t// The check for URL.revokeObjectURL fixes an issue with Opera 12,\r\n\t// which provides URL.createObjectURL but doesn't properly implement it:\r\n\tvar urlAPI = URL || webkitURL;\r\n\r\n\tfunction revokeHelper (img, options) {\r\n\t\tif (img._objectURL && !(options && options.noRevoke)) {\r\n\t\t  imagex.revokeObjectURL(img._objectURL)\r\n\t\t  delete img._objectURL\r\n\t\t}\r\n\t}\r\n\r\n\t// If the callback given to this function returns a blob, it is used as image\r\n\t// source instead of the original url and overrides the file argument used in\r\n\t// the onload and onerror event callbacks:\r\n\timagex.fetchBlob = function (url, callback, options) {\r\n\t\tcallback();\r\n\t}\r\n\r\n\timagex.isInstanceOf = function (type, obj) {\r\n\t\t// Cross-frame instanceof check\r\n\t\treturn Object.prototype.toString.call(obj) === '[object ' + type + ']'\r\n\t}\r\n\r\n\timagex.transform = function (img, options, callback, file, data) {\r\n\t\tcallback(img, data)\r\n\t}\r\n\r\n\timagex.onerror = function (img, event, file, callback, options) {\r\n\t\trevokeHelper(img, options)\r\n\t\tif (callback) {\r\n\t\t  callback.call(img, event)\r\n\t\t}\r\n\t}\r\n\r\n\timagex.onload = function (img, event, file, callback, options) {\r\n\t\trevokeHelper(img, options)\r\n\t\tif (callback) {\r\n\t\t  imagex.transform(img, options, callback, file, {})\r\n\t\t}\r\n\t}\r\n\r\n\timagex.createObjectURL = function (file) {\r\n\t\treturn urlAPI ? urlAPI.createObjectURL(file) : false\r\n\t}\r\n\r\n\timagex.revokeObjectURL = function (url) {\r\n\t\treturn urlAPI ? urlAPI.revokeObjectURL(url) : false\r\n\t}\r\n\r\n\t// Loads a given File object via FileReader interface,\r\n\t// invokes the callback with the event object (load or error).\r\n\t// The result can be read via event.target.result:\r\n\timagex.readFile = function (file, callback, method) {\r\n\t\tif (FileReader) {\r\n\t\t  var fileReader = new FileReader()\r\n\t\t  fileReader.onload = fileReader.onerror = callback\r\n\t\t  method = method || 'readAsDataURL'\r\n\t\t  if (fileReader[method]) {\r\n\t\t    fileReader[method](file)\r\n\t\t    return fileReader\r\n\t\t  }\r\n\t\t}\r\n\t\treturn false\r\n\t}\r\n\t\r\n\treturn skylark.attach(\"graphics.image\", imagex);\r\n});"]}