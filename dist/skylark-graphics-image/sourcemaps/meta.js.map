{"version":3,"sources":["meta.js"],"names":["define","imagex","meta","hasblobSlice","Blob","prototype","slice","webkitSlice","mozSlice","blobSlice","this","apply","arguments","metaDataParsers","jpeg","65505","65517","parseMetaData","file","callback","options","data","that","maxMetaDataSize","DataView","size","type","readFile","call","e","target","error","console","log","markerBytes","markerLength","parsers","i","buffer","result","dataView","offset","maxOffset","byteLength","headLength","getUint16","length","disableImageHead","imageHead","Uint8Array","subarray","hasMetaOption","originalTransform","transform","img"],"mappings":";;;;;;;AAAAA,QACE,WACC,SAASC,GACV,aAEA,IAAIC,KAEAC,EACc,oBAATC,OACNA,KAAKC,UAAUC,OACdF,KAAKC,UAAUE,aACfH,KAAKC,UAAUG,UAEnBP,EAAOQ,UACLN,GACA,WAEE,OADYO,KAAKJ,OAASI,KAAKH,aAAeG,KAAKF,UACtCG,MAAMD,KAAME,YAG7BV,EAAKW,iBACHC,MACEC,SACAC,WAWJd,EAAKe,cAAgB,SAAUC,EAAMC,EAAUC,EAASC,GACtDD,EAAUA,MACVC,EAAOA,MACP,IAAIC,EAAOZ,KAEPa,EAAkBH,EAAQG,iBAAmB,UAE3B,oBAAbC,UACPN,GACAA,EAAKO,MAAQ,IACC,eAAdP,EAAKQ,MACLzB,EAAOQ,YAINR,EAAO0B,SACN1B,EAAOQ,UAAUmB,KAAKV,EAAM,EAAGK,GAC/B,SAAUM,GACR,GAAIA,EAAEC,OAAOC,MAIX,OAFAC,QAAQC,IAAIJ,EAAEC,OAAOC,YACrBZ,EAASE,GAOX,IAKIa,EACAC,EACAC,EACAC,EARAC,EAAST,EAAEC,OAAOS,OAClBC,EAAW,IAAIhB,SAASc,GACxBG,EAAS,EACTC,EAAYF,EAASG,WAAa,EAClCC,EAAaH,EAMjB,GAA8B,QAA1BD,EAASK,UAAU,GAAe,CACpC,KAAOJ,EAASC,KACdR,EAAcM,EAASK,UAAUJ,KAKf,OAAUP,GAAe,OACzB,QAAhBA,IAPuB,CAcvB,GAAIO,GADJN,EAAeK,EAASK,UAAUJ,EAAS,GAAK,GACpBD,EAASG,WAAY,CAC/CX,QAAQC,IAAI,4CACZ,MAGF,GADAG,EAAUlC,EAAKW,gBAAgBC,KAAKoB,GAElC,IAAKG,EAAI,EAAGA,EAAID,EAAQU,OAAQT,GAAK,EACnCD,EAAQC,GAAGT,KACTN,EACAkB,EACAC,EACAN,EACAd,EACAD,GAKNwB,EADAH,GAAUN,GAUTf,EAAQ2B,kBAAoBH,EAAa,IACxCN,EAAOhC,MACTe,EAAK2B,UAAYV,EAAOhC,MAAM,EAAGsC,GAIjCvB,EAAK2B,UAAY,IAAIC,WAAWX,GAAQY,SAAS,EAAGN,SAIxDZ,QAAQC,IAAI,2CAEdd,EAASE,IAEX,sBAGFF,EAASE,IAKbnB,EAAKiD,cAAgB,SAAU/B,GAC7B,OAAOA,GAAWA,EAAQlB,MAG5B,IAAIkD,EAAoBnD,EAAOoD,UAgB/B,OAfApD,EAAOoD,UAAY,SAAUC,EAAKlC,EAASD,EAAUD,EAAMG,GACrDnB,EAAKiD,cAAc/B,GACrBlB,EAAKe,cACHC,EACA,SAAUG,GACR+B,EAAkBxB,KAAK3B,EAAQqD,EAAKlC,EAASD,EAAUD,EAAMG,IAE/DD,EACAC,GAGF+B,EAAkBzC,MAAMV,EAAQW,YAI7BX,EAAOC,KAAOA","file":"../meta.js","sourcesContent":["define([\r\n  \"./image\",\r\n], function(imagex) {\r\n  'use strict'\r\n\r\n  var meta = {};\r\n\r\n  var hasblobSlice =\r\n    typeof Blob !== 'undefined' &&\r\n    (Blob.prototype.slice ||\r\n      Blob.prototype.webkitSlice ||\r\n      Blob.prototype.mozSlice)\r\n\r\n  imagex.blobSlice =\r\n    hasblobSlice &&\r\n    function () {\r\n      var slice = this.slice || this.webkitSlice || this.mozSlice\r\n      return slice.apply(this, arguments)\r\n    }\r\n\r\n  meta.metaDataParsers = {\r\n    jpeg: {\r\n      0xffe1: [], // APP1 marker\r\n      0xffed: [] // APP13 marker\r\n    }\r\n  }\r\n\r\n  // Parses image meta data and calls the callback with an object argument\r\n  // with the following properties:\r\n  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\r\n  // The options argument accepts an object and supports the following\r\n  // properties:\r\n  // * maxMetaDataSize: Defines the maximum number of bytes to parse.\r\n  // * disableImageHead: Disables creating the imageHead property.\r\n  meta.parseMetaData = function (file, callback, options, data) {\r\n    options = options || {}\r\n    data = data || {}\r\n    var that = this\r\n    // 256 KiB should contain all EXIF/ICC/IPTC segments:\r\n    var maxMetaDataSize = options.maxMetaDataSize || 262144\r\n    var noMetaData = !(\r\n      typeof DataView !== 'undefined' &&\r\n      file &&\r\n      file.size >= 12 &&\r\n      file.type === 'image/jpeg' &&\r\n      imagex.blobSlice\r\n    )\r\n    if (\r\n      noMetaData ||\r\n      !imagex.readFile(\r\n        imagex.blobSlice.call(file, 0, maxMetaDataSize),\r\n        function (e) {\r\n          if (e.target.error) {\r\n            // FileReader error\r\n            console.log(e.target.error)\r\n            callback(data)\r\n            return\r\n          }\r\n          // Note on endianness:\r\n          // Since the marker and length bytes in JPEG files are always\r\n          // stored in big endian order, we can leave the endian parameter\r\n          // of the DataView methods undefined, defaulting to big endian.\r\n          var buffer = e.target.result\r\n          var dataView = new DataView(buffer)\r\n          var offset = 2\r\n          var maxOffset = dataView.byteLength - 4\r\n          var headLength = offset\r\n          var markerBytes\r\n          var markerLength\r\n          var parsers\r\n          var i\r\n          // Check for the JPEG marker (0xffd8):\r\n          if (dataView.getUint16(0) === 0xffd8) {\r\n            while (offset < maxOffset) {\r\n              markerBytes = dataView.getUint16(offset)\r\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\r\n              // which contain application-specific meta-data like\r\n              // Exif, ICC and IPTC data and text comments:\r\n              if (\r\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\r\n                markerBytes === 0xfffe\r\n              ) {\r\n                // The marker bytes (2) are always followed by\r\n                // the length bytes (2), indicating the length of the\r\n                // marker segment, which includes the length bytes,\r\n                // but not the marker bytes, so we add 2:\r\n                markerLength = dataView.getUint16(offset + 2) + 2\r\n                if (offset + markerLength > dataView.byteLength) {\r\n                  console.log('Invalid meta data: Invalid segment size.')\r\n                  break\r\n                }\r\n                parsers = meta.metaDataParsers.jpeg[markerBytes]\r\n                if (parsers) {\r\n                  for (i = 0; i < parsers.length; i += 1) {\r\n                    parsers[i].call(\r\n                      that,\r\n                      dataView,\r\n                      offset,\r\n                      markerLength,\r\n                      data,\r\n                      options\r\n                    )\r\n                  }\r\n                }\r\n                offset += markerLength\r\n                headLength = offset\r\n              } else {\r\n                // Not an APPn or COM marker, probably safe to\r\n                // assume that this is the end of the meta data\r\n                break\r\n              }\r\n            }\r\n            // Meta length must be longer than JPEG marker (2)\r\n            // plus APPn marker (2), followed by length bytes (2):\r\n            if (!options.disableImageHead && headLength > 6) {\r\n              if (buffer.slice) {\r\n                data.imageHead = buffer.slice(0, headLength)\r\n              } else {\r\n                // Workaround for IE10, which does not yet\r\n                // support ArrayBuffer.slice:\r\n                data.imageHead = new Uint8Array(buffer).subarray(0, headLength)\r\n              }\r\n            }\r\n          } else {\r\n            console.log('Invalid JPEG file: Missing JPEG marker.')\r\n          }\r\n          callback(data)\r\n        },\r\n        'readAsArrayBuffer'\r\n      )\r\n    ) {\r\n      callback(data)\r\n    }\r\n  }\r\n\r\n  // Determines if meta data should be loaded automatically:\r\n  meta.hasMetaOption = function (options) {\r\n    return options && options.meta\r\n  }\r\n\r\n  var originalTransform = imagex.transform\r\n  imagex.transform = function (img, options, callback, file, data) {\r\n    if (meta.hasMetaOption(options)) {\r\n      meta.parseMetaData(\r\n        file,\r\n        function (data) {\r\n          originalTransform.call(imagex, img, options, callback, file, data)\r\n        },\r\n        options,\r\n        data\r\n      )\r\n    } else {\r\n      originalTransform.apply(imagex, arguments)\r\n    }\r\n  }\r\n\r\n  return imagex.meta = meta;\r\n})"]}